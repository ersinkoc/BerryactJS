import{isSignal}from '../core/signal.js';const ELEMENT_NODE=1;const TEXT_NODE=3;const COMMENT_NODE=8;export class TemplateNode{constructor(type,tag=null,props={},children=[]){this.type=type;this.tag=tag;this.props=props;this.children=children;this.key=props.key;}}export function parseTemplate(strings,values){const template=strings.reduce((acc,str,i)=>{return acc+str+(i < values.length ? `__PLACEHOLDER_${i}__` : '');},'');const parser=new DOMParser();const doc=parser.parseFromString(`<template>${template}</template>`,'text/html');const templateElement=doc.querySelector('template');if(!templateElement){throw new Error('Invalid template');}return parseNode(templateElement.content,values);}function parseNode(node,values){if(node.nodeType===TEXT_NODE){return parseTextNode(node.textContent,values);}if(node.nodeType===ELEMENT_NODE){return parseElementNode(node,values);}if(node.nodeType===COMMENT_NODE){return null;}if(node.hasChildNodes()){const children=Array.from(node.childNodes).map(child=> parseNode(child,values)).filter(Boolean);if(children.length===1){return children[0];}return new TemplateNode('fragment',null,{},children);}return null;}function parseTextNode(text,values){const parts=text.split(/__PLACEHOLDER_(\d+)__/);if(parts.length===1){const trimmed=text.trim();if(!trimmed)return null;return new TemplateNode('text',null,{},[text]);}const children=[];for(let i=0;i < parts.length;i++){if(i % 2===0){if(parts[i]){children.push(parts[i]);}}else{const valueIndex=parseInt(parts[i]);const value=values[valueIndex];if(value !==undefined && value !==null){children.push(value);}}}if(children.length===0){return null;}if(children.length===1){return children[0];}return new TemplateNode('text',null,{},children);}function parseElementNode(element,values){const tag=element.tagName.toLowerCase();const props={};Array.from(element.attributes).forEach(attr=>{const name=attr.name;const value=attr.value;if(value.includes('__PLACEHOLDER_')){const match=value.match(/__PLACEHOLDER_(\d+)__/);if(match){const valueIndex=parseInt(match[1]);props[name]=values[valueIndex];}}else{props[name]=value;}});const children=Array.from(element.childNodes).map(child=> parseNode(child,values)).filter(Boolean);return new TemplateNode('element',tag,props,children);}export function html(strings,...values){try{return parseTemplate(strings,values);}catch(error){console.error('Template parsing error:',error);return new TemplateNode('text',null,{},['[Template Error]']);}}export function fragment(...children){return new TemplateNode('fragment',null,{},children.flat());}