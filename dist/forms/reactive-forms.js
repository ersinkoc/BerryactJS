import{signal,computed,effect,batch}from '../core/signal-enhanced.js';import{createPlugin}from '../core/plugin.js';export const Validators={required:(message='This field is required')=>({name: 'required',validate:(value)=>{if(value===null || value===undefined || value===''){return{valid: false,message};}return{valid: true};}}),minLength:(length,message=`Minimum length is ${length}`)=>({name: 'minLength',validate:(value)=>{if(!value || value.length < length){return{valid: false,message};}return{valid: true};}}),maxLength:(length,message=`Maximum length is ${length}`)=>({name: 'maxLength',validate:(value)=>{if(value && value.length > length){return{valid: false,message};}return{valid: true};}}),pattern:(regex,message='Invalid format')=>({name: 'pattern',validate:(value)=>{if(!value || !regex.test(value)){return{valid: false,message};}return{valid: true};}}),email:(message='Invalid email address')=>({name: 'email',validate:(value)=>{const emailRegex=/^[^\s@]+@[^\s@]+\.[^\s@]+$/;if(!value || !emailRegex.test(value)){return{valid: false,message};}return{valid: true};}}),min:(minValue,message=`Minimum value is ${minValue}`)=>({name: 'min',validate:(value)=>{if(value===null || value===undefined || Number(value)< minValue){return{valid: false,message};}return{valid: true};}}),max:(maxValue,message=`Maximum value is ${maxValue}`)=>({name: 'max',validate:(value)=>{if(value !==null && value !==undefined && Number(value)> maxValue){return{valid: false,message};}return{valid: true};}}),custom:(validateFn,message='Invalid value')=>({name: 'custom',validate: async(value,field)=>{try{const result=await validateFn(value,field);if(result===true){return{valid: true};}return{valid: false,message: result || message};}catch(error){return{valid: false,message: error.message || message};}}}),match:(otherFieldName,message='Fields do not match')=>({name: 'match',validate:(value,field)=>{const form=field.form;if(!form)return{valid: true};const otherField=form.getField(otherFieldName);if(!otherField)return{valid: true};if(value !==otherField.value.value){return{valid: false,message};}return{valid: true};}}),requiredIf:(condition,message='This field is required')=>({name: 'requiredIf',validate:(value,field)=>{const shouldValidate=typeof condition==='function' ? condition(field.form?.values.value): condition;if(shouldValidate &&(!value || value==='')){return{valid: false,message};}return{valid: true};}})};export class FormField{constructor(name,options={}){this.name=name;this.form=null;this.value=signal(options.value ?? '');this.errors=signal([]);this.touched=signal(false);this.dirty=signal(false);this.validating=signal(false);this.focused=signal(false);this.validators=options.validators ||[];this.asyncValidators=options.asyncValidators ||[];this.transform=options.transform || null;this.parse=options.parse || null;this.format=options.format || null;this.debounce=options.debounce || 0;this.valid=computed(()=> this.errors.value.length===0);this.invalid=computed(()=> this.errors.value.length > 0);this.pristine=computed(()=> !this.dirty.value);this.untouched=computed(()=> !this.touched.value);this.error=computed(()=>{const errors=this.errors.value;return errors.length > 0 ? errors[0].message : null;});this._setupValidation();}_setupValidation(){let validateTimeout;effect(()=>{const value=this.value.value;clearTimeout(validateTimeout);validateTimeout=setTimeout(()=>{this.validate();},this.debounce);});}async validate(options={}){const{updateTouched=false,force=false}=options;if(!force && !this.dirty.value && !this.touched.value){return true;}if(updateTouched){this.touched.value=true;}this.validating.value=true;const errors=[];const value=this.getValue();try{for(const validator of this.validators){const result=validator.validate(value,this);if(!result.valid){errors.push({rule: validator.name,message: result.message});}}if(errors.length===0 && this.asyncValidators.length > 0){for(const validator of this.asyncValidators){const result=await validator.validate(value,this);if(!result.valid){errors.push({rule: validator.name,message: result.message});}}}}finally{this.validating.value=false;}this.errors.value=errors;return errors.length===0;}getValue(){const rawValue=this.value.value;if(this.parse){return this.parse(rawValue);}return rawValue;}setValue(value,options={}){const{emitEvent=true,updateDirty=true}=options;if(this.transform){value=this.transform(value);}if(this.format){value=this.format(value);}this.value.value=value;if(updateDirty){this.dirty.value=true;}if(emitEvent && this.form){this.form._notifyChange(this.name,value);}}reset(value=''){batch(()=>{this.value.value=value;this.errors.value=[];this.touched.value=false;this.dirty.value=false;this.validating.value=false;this.focused.value=false;});}markAsTouched(){this.touched.value=true;}markAsUntouched(){this.touched.value=false;}markAsDirty(){this.dirty.value=true;}markAsPristine(){this.dirty.value=false;}setErrors(errors){this.errors.value=errors;}addError(error){this.errors.value=[...this.errors.value,error];}clearErrors(){this.errors.value=[];}focus(){this.focused.value=true;}blur(){this.focused.value=false;this.touched.value=true;}bind(){return{value: this.value.value,onInput:(e)=> this.setValue(e.target.value),onFocus:()=> this.focus(),onBlur:()=> this.blur(),'aria-invalid': this.invalid.value,'aria-describedby': this.error.value ? `${this.name}-error` : undefined};}}export class FormGroup{constructor(fields={},options={}){this.fields=new Map();this.options=options;this.submitting=signal(false);this.submitted=signal(false);this.submitCount=signal(0);Object.entries(fields).forEach(([name,fieldOptions])=>{this.addField(name,fieldOptions);});this.values=computed(()=>{const values={};this.fields.forEach((field,name)=>{values[name]=field.getValue();});return values;});this.errors=computed(()=>{const errors={};this.fields.forEach((field,name)=>{if(field.errors.value.length > 0){errors[name]=field.errors.value;}});return errors;});this.valid=computed(()=>{return Array.from(this.fields.values()).every(field=> field.valid.value);});this.invalid=computed(()=> !this.valid.value);this.dirty=computed(()=>{return Array.from(this.fields.values()).some(field=> field.dirty.value);});this.pristine=computed(()=> !this.dirty.value);this.touched=computed(()=>{return Array.from(this.fields.values()).some(field=> field.touched.value);});this.validating=computed(()=>{return Array.from(this.fields.values()).some(field=> field.validating.value);});this._changeHandlers=new Set();this._submitHandlers=new Set();}addField(name,options){const field=options instanceof FormField ? options : new FormField(name,options);field.form=this;this.fields.set(name,field);return field;}removeField(name){const field=this.fields.get(name);if(field){field.form=null;this.fields.delete(name);}}getField(name){return this.fields.get(name);}getValue(name){const field=this.fields.get(name);return field ? field.getValue(): undefined;}setValue(name,value,options){const field=this.fields.get(name);if(field){field.setValue(value,options);}}setValues(values,options){batch(()=>{Object.entries(values).forEach(([name,value])=>{this.setValue(name,value,options);});});}async validate(options={}){const results=await Promise.all(Array.from(this.fields.values()).map(field=> field.validate(options)));return results.every(valid=> valid);}async submit(handler){if(this.submitting.value)return;this.submitting.value=true;this.submitted.value=true;this.submitCount.value++;try{const isValid=await this.validate({updateTouched: true});if(!isValid){const firstErrorField=Array.from(this.fields.values()).find(field=> field.invalid.value);if(firstErrorField && this.options.focusOnError){this._notifyFocus(firstErrorField.name);}return;}const values=this.values.value;await handler(values,this);this._submitHandlers.forEach(h=> h(values));if(this.options.resetOnSubmit){this.reset();}}finally{this.submitting.value=false;}}reset(values={}){batch(()=>{this.fields.forEach((field,name)=>{field.reset(values[name]|| '');});this.submitted.value=false;this.submitCount.value=0;});}markAllAsTouched(){this.fields.forEach(field=> field.markAsTouched());}markAllAsUntouched(){this.fields.forEach(field=> field.markAsUntouched());}onChange(handler){this._changeHandlers.add(handler);return()=> this._changeHandlers.delete(handler);}onSubmit(handler){this._submitHandlers.add(handler);return()=> this._submitHandlers.delete(handler);}_notifyChange(fieldName,value){this._changeHandlers.forEach(handler=>{handler({fieldName,value,values: this.values.value});});}_notifyFocus(fieldName){if(this.options.onFocusField){this.options.onFocusField(fieldName);}}bind(){return{onSubmit:(e)=>{e.preventDefault();if(this.options.onSubmit){this.submit(this.options.onSubmit);}}};}}export class FormArray{constructor(initialItems=[],fieldFactory){this.items=signal(initialItems);this.fieldFactory=fieldFactory;this.length=computed(()=> this.items.value.length);this.valid=computed(()=> this.items.value.every(item=> item.valid.value));this.invalid=computed(()=> !this.valid.value);this.dirty=computed(()=> this.items.value.some(item=> item.dirty.value));this.values=computed(()=> this.items.value.map(item=> item.getValue()));}push(value){const field=this.fieldFactory(value);this.items.value=[...this.items.value,field];return field;}removeAt(index){const items=[...this.items.value];items.splice(index,1);this.items.value=items;}insert(index,value){const field=this.fieldFactory(value);const items=[...this.items.value];items.splice(index,0,field);this.items.value=items;return field;}clear(){this.items.value=[];}setItems(values){this.items.value=values.map(value=> this.fieldFactory(value));}async validate(options){const results=await Promise.all(this.items.value.map(field=> field.validate(options)));return results.every(valid=> valid);}reset(){this.items.value.forEach(field=> field.reset());}}export function createForm(config){const fields={};Object.entries(config).forEach(([name,fieldConfig])=>{if(typeof fieldConfig==='string' || fieldConfig===null){fields[name]={value: fieldConfig};}else if(Array.isArray(fieldConfig)){fields[name]={value: fieldConfig[0],validators: fieldConfig[1]};}else{fields[name]=fieldConfig;}});return new FormGroup(fields);}export function useForm(config,options){const[form]=useState(()=>{if(config instanceof FormGroup){return config;}return createForm(config);});useEffect(()=>{return()=>{};},[]);return form;}export const ReactiveFormsPlugin=createPlugin({name: 'reactive-forms',version: '1.0.0',setup(app,context){this.provide('forms',{FormField,FormGroup,FormArray,Validators,createForm,useForm});app.forms={create: createForm,validators: Validators};}});