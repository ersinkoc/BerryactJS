import fs from 'fs';import path from 'path';import{parse}from '@babel/parser';import traverse from '@babel/traverse';import generate from '@babel/generator';export class TreeShaker{constructor(options={}){this.options={entryPoints:['index.js'],excludePatterns:[/\.test\.js$/,/\.spec\.js$/],preserveComments: false,minify: false,...options};this.usedExports=new Set();this.moduleGraph=new Map();this.deadCode=new Set();}async shake(srcDir){console.log('ðŸŒ³ Tree shaking Berryact JS...');await this.buildModuleGraph(srcDir);for(const entry of this.options.entryPoints){await this.markUsedExports(entry);}const removedBytes=await this.removeUnusedCode(srcDir);console.log(`âœ… Tree shaking complete! Removed ${removedBytes}bytes of unused code`);return{usedExports: this.usedExports.size,deadCode: this.deadCode.size,savedBytes: removedBytes};}async buildModuleGraph(srcDir){const files=await this.findJSFiles(srcDir);for(const file of files){const content=await fs.promises.readFile(file,'utf-8');const ast=this.parseFile(content);const moduleInfo={path: file,exports: this.extractExports(ast),imports: this.extractImports(ast),ast: ast};this.moduleGraph.set(file,moduleInfo);}}async findJSFiles(dir){const files=[];const items=await fs.promises.readdir(dir,{withFileTypes: true});for(const item of items){const fullPath=path.join(dir,item.name);if(item.isDirectory()){files.push(...await this.findJSFiles(fullPath));}else if(item.isFile()&& item.name.endsWith('.js')){if(!this.options.excludePatterns.some(pattern=> pattern.test(fullPath))){files.push(fullPath);}}}return files;}parseFile(content){try{return parse(content,{sourceType: 'module',plugins:['jsx','typescript','decorators-legacy','classProperties','objectRestSpread','asyncGenerators','functionBind','exportDefaultFrom','exportNamespaceFrom','dynamicImport','nullishCoalescingOperator','optionalChaining']});}catch(error){console.warn(`Warning: Could not parse file: ${error.message}`);return null;}}extractExports(ast){const exports=new Set();if(!ast)return exports;traverse(ast,{ExportNamedDeclaration(path){if(path.node.declaration){if(path.node.declaration.type==='VariableDeclaration'){path.node.declaration.declarations.forEach(decl=>{if(decl.id.type==='Identifier'){exports.add(decl.id.name);}});}else if(path.node.declaration.type==='FunctionDeclaration'){exports.add(path.node.declaration.id.name);}else if(path.node.declaration.type==='ClassDeclaration'){exports.add(path.node.declaration.id.name);}}if(path.node.specifiers){path.node.specifiers.forEach(spec=>{if(spec.type==='ExportSpecifier'){exports.add(spec.exported.name);}});}},ExportDefaultDeclaration(path){exports.add('default');}});return exports;}extractImports(ast){const imports=new Map();if(!ast)return imports;traverse(ast,{ImportDeclaration(path){const source=path.node.source.value;const imported=new Set();path.node.specifiers.forEach(spec=>{if(spec.type==='ImportDefaultSpecifier'){imported.add('default');}else if(spec.type==='ImportSpecifier'){imported.add(spec.imported.name);}else if(spec.type==='ImportNamespaceSpecifier'){imported.add('*');}});imports.set(source,imported);}});return imports;}async markUsedExports(entryPoint){const module=this.moduleGraph.get(entryPoint);if(!module)return;module.exports.forEach(exp=>{this.usedExports.add(`${entryPoint}:${exp}`);});for(const[importPath,importedNames]of module.imports){const resolvedPath=this.resolveImport(importPath,entryPoint);if(resolvedPath){importedNames.forEach(name=>{this.usedExports.add(`${resolvedPath}:${name}`);});await this.markUsedExports(resolvedPath);}}}resolveImport(importPath,currentFile){if(importPath.startsWith('./')|| importPath.startsWith('../')){const resolved=path.resolve(path.dirname(currentFile),importPath);if(this.moduleGraph.has(resolved+'.js')){return resolved+'.js';}if(this.moduleGraph.has(resolved)){return resolved;}}for(const modulePath of this.moduleGraph.keys()){if(modulePath.includes(importPath)){return modulePath;}}return null;}async removeUnusedCode(srcDir){let removedBytes=0;for(const[filePath,module]of this.moduleGraph){const originalContent=await fs.promises.readFile(filePath,'utf-8');const optimizedAst=this.removeUnusedExports(module.ast,filePath);if(optimizedAst){const optimizedContent=generate(optimizedAst,{comments: this.options.preserveComments,compact: this.options.minify,minified: this.options.minify}).code;if(optimizedContent !==originalContent){await fs.promises.writeFile(filePath,optimizedContent);removedBytes+=originalContent.length-optimizedContent.length;}}}return removedBytes;}removeUnusedExports(ast,filePath){if(!ast)return null;const nodesToRemove=[];traverse(ast,{ExportNamedDeclaration(path){const exportNames=new Set();if(path.node.declaration){if(path.node.declaration.type==='VariableDeclaration'){path.node.declaration.declarations.forEach(decl=>{if(decl.id.type==='Identifier'){exportNames.add(decl.id.name);}});}else if(path.node.declaration.type==='FunctionDeclaration'){exportNames.add(path.node.declaration.id.name);}else if(path.node.declaration.type==='ClassDeclaration'){exportNames.add(path.node.declaration.id.name);}}if(path.node.specifiers){path.node.specifiers.forEach(spec=>{if(spec.type==='ExportSpecifier'){exportNames.add(spec.exported.name);}});}const hasUsedExport=Array.from(exportNames).some(name=> this.usedExports.has(`${filePath}:${name}`));if(!hasUsedExport && exportNames.size > 0){nodesToRemove.push(path);exportNames.forEach(name=>{this.deadCode.add(`${filePath}:${name}`);});}},ExportDefaultDeclaration(path){if(!this.usedExports.has(`${filePath}:default`)){nodesToRemove.push(path);this.deadCode.add(`${filePath}:default`);}}});nodesToRemove.forEach(path=>{path.remove();});return ast;}static async optimize(srcDir,options={}){const shaker=new TreeShaker(options);return await shaker.shake(srcDir);}}export default TreeShaker;