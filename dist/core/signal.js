let currentEffect=null;let batchDepth=0;let batchedEffects=new Set();export function signal(initialValue){const observers=new Set();let value=initialValue;let version=0;const signalObject={get value(){if(currentEffect){observers.add(currentEffect);currentEffect.dependencies.add(signalObject);}return value;},set value(newValue){if(value !==newValue){value=newValue;version++;notify();}},get version(){return version;},peek(){return value;},notify(){notify();},dispose(){observers.clear();}};function notify(){if(batchDepth > 0){observers.forEach(observer=> batchedEffects.add(observer));}else{observers.forEach(observer=>{if(observer.active){observer.execute();}});}}return signalObject;}export function computed(fn){let cachedValue;let isValid=false;const dependencies=new Set();const observers=new Set();const effectObject={dependencies,active: true,execute:()=>{isValid=false;notify();}};function recompute(){const prevEffect=currentEffect;currentEffect=effectObject;dependencies.forEach(dep=>{if(dep.observers){dep.observers.delete(effectObject);}});dependencies.clear();try{cachedValue=fn();isValid=true;}finally{currentEffect=prevEffect;}return cachedValue;}function notify(){if(batchDepth > 0){observers.forEach(observer=> batchedEffects.add(observer));}else{observers.forEach(observer=>{if(observer.active){observer.execute();}});}}const computedSignal={get value(){if(currentEffect){observers.add(currentEffect);currentEffect.dependencies.add(computedSignal);}if(!isValid){recompute();}return cachedValue;},set value(newValue){throw new Error('Cannot set computed signal');},get version(){return 0;},peek(){return cachedValue;},notify(){notify();},dispose(){effectObject.active=false;dependencies.forEach(dep=>{if(dep.observers){dep.observers.delete(effectObject);}});dependencies.clear();observers.clear();}};recompute();return computedSignal;}export function effect(fn,options={}){const{immediate=true}=options;const dependencies=new Set();let isActive=true;let cleanup=null;const effectObject={dependencies,active: isActive,execute(){if(!isActive)return;if(cleanup){cleanup();cleanup=null;}const prevEffect=currentEffect;currentEffect=effectObject;dependencies.forEach(dep=>{if(dep.observers){dep.observers.delete(effectObject);}});dependencies.clear();try{const result=fn();if(typeof result==='function'){cleanup=result;}}finally{currentEffect=prevEffect;}},dispose(){isActive=false;if(cleanup){cleanup();cleanup=null;}dependencies.forEach(dep=>{if(dep.observers){dep.observers.delete(effectObject);}});dependencies.clear();}};if(immediate){effectObject.execute();}return effectObject;}export function batch(fn){if(batchDepth===0){batchedEffects.clear();}batchDepth++;try{const result=fn();if(batchDepth===1){batchedEffects.forEach(effect=>{if(effect.active){effect.execute();}});batchedEffects.clear();}return result;}finally{batchDepth--;}}export function untrack(fn){const prevEffect=currentEffect;currentEffect=null;try{return fn();}finally{currentEffect=prevEffect;}}export function isSignal(value){return value && typeof value==='object' && 'value' in value && 'peek' in value;}