import{signal}from './signal-enhanced.js';export function compose(...middleware){if(middleware.length===0){return(context,next)=> next();}if(middleware.length===1){return middleware[0];}return function composedMiddleware(context,next){let index=-1;function dispatch(i){if(i <=index){return Promise.reject(new Error('next()called multiple times'));}index=i;const fn=middleware[i];if(!fn){return Promise.resolve(next ? next(): undefined);}try{return Promise.resolve(fn(context,()=> dispatch(i+1)));}catch(error){return Promise.reject(error);}}return dispatch(0);};}export class MiddlewarePipeline{constructor(options={}){this.middleware=[];this.options={async: true,errorHandler: null,...options};}use(middleware){if(typeof middleware !=='function'){throw new TypeError('Middleware must be a function');}this.middleware.push(middleware);return this;}remove(middleware){const index=this.middleware.indexOf(middleware);if(index >-1){this.middleware.splice(index,1);}return this;}clear(){this.middleware=[];return this;}async execute(context,finalHandler){const chain=compose(...this.middleware);try{if(this.options.async){return await chain(context,finalHandler);}else{return chain(context,finalHandler);}}catch(error){if(this.options.errorHandler){return this.options.errorHandler(error,context);}throw error;}}createExecutor(finalHandler){return(context)=> this.execute(context,finalHandler);}}export const RouterMiddleware={auth:(options={})=>{const{isAuthenticated,redirectTo='/login',message='Authentication required'}=options;return async(context,next)=>{const{to,from,router}=context;if(!isAuthenticated()){if(message){console.warn(message);}router.push(redirectTo,{query:{redirect: to.path}});return false;}return next();};},rbac:(options={})=>{const{getUserRole,allowedRoles=[],redirectTo='/forbidden'}=options;return async(context,next)=>{const{to,router}=context;const userRole=getUserRole();if(!allowedRoles.includes(userRole)){router.push(redirectTo);return false;}return next();};},logger:(options={})=>{const{logger=console,level='info'}=options;return async(context,next)=>{const{to,from}=context;const start=Date.now();logger[level](`Navigation: ${from.path}-> ${to.path}`);const result=await next();const duration=Date.now()-start;logger[level](`Navigation completed in ${duration}ms`);return result;};},progress:(options={})=>{const{delay=100}=options;let timeoutId;return async(context,next)=>{const{router}=context;timeoutId=setTimeout(()=>{if(router.progress){router.progress.start();}},delay);try{const result=await next();clearTimeout(timeoutId);if(router.progress){router.progress.finish();}return result;}catch(error){clearTimeout(timeoutId);if(router.progress){router.progress.fail();}throw error;}};},cache:(options={})=>{const{storage=sessionStorage,key='router-cache',ttl=5*60*1000}=options;const cache=new Map();return async(context,next)=>{const{to}=context;const cacheKey=`${key}:${to.path}`;const cached=cache.get(cacheKey);if(cached && Date.now()-cached.timestamp < ttl){context.cachedData=cached.data;return cached.result;}const result=await next();cache.set(cacheKey,{result,data: context.data,timestamp: Date.now()});try{storage.setItem(key,JSON.stringify([...cache]));}catch(e){}return result;};}};export const StoreMiddleware={logger:(options={})=>{const{logger=console,collapsed=true,filter=null,transformer=null}=options;return store=> next=> action=>{if(filter && !filter(action,store.getState())){return next(action);}const prevState=store.getState();const started=Date.now();const result=next(action);const duration=Date.now()-started;const nextState=store.getState();const data=transformer ? transformer({action,prevState,nextState,duration}):{action,prevState,nextState,duration};if(collapsed){logger.groupCollapsed(`${action.type}(${duration}ms)`);}else{logger.group(`${action.type}(${duration}ms)`);}logger.log('Action:',data.action);logger.log('Previous State:',data.prevState);logger.log('Next State:',data.nextState);logger.log('Duration:',`${data.duration}ms`);logger.groupEnd();return result;};},thunk:(options={})=>{const{extraArgument}=options;return store=> next=> action=>{if(typeof action==='function'){return action(store.dispatch,store.getState,extraArgument);}return next(action);};},promise:()=>{return store=> next=> action=>{if(!action.promise){return next(action);}const{type,promise,...rest}=action;next({...rest,type: `${type}_PENDING`});return promise .then(result=>{next({...rest,type: `${type}_SUCCESS`,payload: result});return result;}).catch(error=>{next({...rest,type: `${type}_ERROR`,error: true,payload: error});throw error;});};},validator:(options={})=>{const{rules={}}=options;return store=> next=> action=>{const rule=rules[action.type];if(rule){const state=store.getState();const validation=rule(action,state);if(validation !==true){console.error(`Validation failed for ${action.type}:`,validation);return;}}return next(action);};},persist:(options={})=>{const{key='store',storage=localStorage,whitelist=null,blacklist=null,throttle=1000}=options;let timeoutId;return store=>{try{const savedState=storage.getItem(key);if(savedState){const parsed=JSON.parse(savedState);store.replaceState(parsed);}}catch(e){console.error('Failed to load persisted state:',e);}return next=> action=>{const result=next(action);clearTimeout(timeoutId);timeoutId=setTimeout(()=>{try{const state=store.getState();const stateToPersist=filterState(state,whitelist,blacklist);storage.setItem(key,JSON.stringify(stateToPersist));}catch(e){console.error('Failed to persist state:',e);}},throttle);return result;};};},undoable:(options={})=>{const{limit=10}=options;const history=[];let currentIndex=-1;return store=>{store.undo=()=>{if(currentIndex > 0){currentIndex--;store.replaceState(history[currentIndex]);}};store.redo=()=>{if(currentIndex < history.length-1){currentIndex++;store.replaceState(history[currentIndex]);}};store.canUndo=()=> currentIndex > 0;store.canRedo=()=> currentIndex < history.length-1;return next=> action=>{if(action.type==='UNDO' || action.type==='REDO'){return;}const result=next(action);currentIndex++;history.splice(currentIndex,history.length-currentIndex,store.getState());if(history.length > limit){history.shift();currentIndex--;}return result;};};}};export function createMiddlewarePipeline(name,options={}){const pipeline=new MiddlewarePipeline(options);const state=signal({executing: false,lastExecution: null,errorCount: 0});return{name,pipeline,state,use(middleware){pipeline.use(middleware);return this;},async execute(context){state.value={...state.value,executing: true};try{const result=await pipeline.execute(context);state.value={executing: false,lastExecution: new Date(),errorCount: 0};return result;}catch(error){state.value={executing: false,lastExecution: new Date(),errorCount: state.value.errorCount+1};throw error;}},createBoundMiddleware(){return(context,next)=>{return this.execute({...context,next});};}};}function filterState(state,whitelist,blacklist){if(!whitelist && !blacklist){return state;}const filtered={};Object.keys(state).forEach(key=>{if(blacklist && blacklist.includes(key)){return;}if(whitelist && !whitelist.includes(key)){return;}filtered[key]=state[key];});return filtered;}